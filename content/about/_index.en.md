---
title: About (Engineering)
date: 2021-12-03
publishdate: 2021-12-03
---

I started coding at **10**. Early 80s. My first computer was a **Tandy MC-10** â€” a real shock (in the best sense).
I still remember my first BASIC lines and that moment when you hit *Run*â€¦ and something happens because **you wrote it**.

Then came my teenage years and the machines that shaped my taste: **Atari ST**, **Amiga 500**. The Amiga, especially,
was a turning point: an OS, a terminal, tools, a â€œsystemsâ€ mindset. Thatâ€™s when development became a discipline, not a hobby.

## What Iâ€™ve been doing since

Iâ€™ve spent **more than two decades** building and running software in demanding environments:
first **C/Unix** systems (billing, maintenance, production support â€” the real world, the kind that trains your standards
for â€œsoftware that actually runsâ€), then **Java/JVM** platforms, **software architecture**, and today **tech leadership**
on **reliability and security** topics.

The common thread hasnâ€™t changed:

- **APIs as products**: design, governance, tooling, and everything that prevents slow motion chaos.
- **Dev *and* Run**: what matters is what happens after â€œit works on my machineâ€.
- **Pragmatic stacks**: C, Java, Kotlin, JavaScriptâ€¦ not for collecting languages, but because constraints move and software must ship.
- **Technical leadership**: unblocking, making decisions explicit, keeping systems coherent as they scale.

## What I refuse to do

I donâ€™t sell **magic potions**.

- No â€œjust adopt X and everything will be fineâ€.
- No architecture cosplay: patterns without pressure, abstractions without proof.
- No â€œspeedâ€ achieved by pushing debt onto the next team â€” or *future you in 18 months*.
- No â€œbest practicesâ€ thrown around like commandments.

When a choice has trade-offs (it always does), Iâ€™ll say it plainly: what you gain, what it costs, and what becomes harder later.

## The problems Iâ€™m genuinely interested in

Iâ€™m at my best on problems where **reality** forces clarity:

- **Platforms and internal tooling**: DX, guardrails, conventions that reduce chaos without killing autonomy.
- **API design and integration**: contracts, versioning, compatibility, and edge cases that only show up in production.
- **Production-driven architecture**: observability, failure modes, security constraints, operability, 2am support.
- **Refactoring living systems**: reducing coupling, shrinking blast radius, paying down debt intentionally â€” without stopping delivery.
- **CI/CD and release discipline**: making shipping a reliable process, not an event.

## What youâ€™ll find on this blog

I write here about what I use to keep projects readable and shippable:

- architecture & modularity (what to split, what to keep together)
- signal-driven refactoring (not mood-driven)
- JVM (Kotlin/Java), CI/CD, and tooling that actually changes day-to-day work
- AI as an engineering tool â€” and *when not to use it*
- Hugo / editorial pipeline (to share knowledge simply)

## Transmission: sharing and documenting

I also do the â€œless visibleâ€ but decisive part: reviews, documentation, mentoring, internal workshops, practice sharing â€”
everything that prevents teams from relearning the same lessons the hard way.

## Outside of work

- I used to coach **Cesta Punta** â€” Iâ€™ll let you look that one up (timing and reflexes).
- Iâ€™ve been practicing **judo** for a few years (discipline and consistency).
- I maintain open-source modules around tabletop RPG tooling (Foundry VTT), because building tools is instructive
  (and it keeps your ego in check).

ğŸ‘‰ [Licence]({{< relref "about/licensing" >}})
